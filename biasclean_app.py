# -*- coding: utf-8 -*-
"""biasclean_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VkcJ0Ak4cZ6u8mZMYqeabisIR6wPinxV
"""

"""
Flask Web Wrapper for Universal BiasClean Pipeline - biasclean_app.py
Production Deployment for Render.com
Author: CS Principal Engineer with 20 years Python experience
"""

import os
import json
import tempfile
import traceback
from datetime import datetime
from typing import Dict, Any

import pandas as pd
from flask import Flask, request, jsonify, render_template, send_file

# Import your pipeline (adjusted for deployment)
# Note: We're removing Colab/UI dependencies while keeping core logic
from biasclean_7 import UniversalBiasClean, DOMAIN_CONFIGS

# ============================================================================
# FLASK APP CONFIGURATION
# ============================================================================

# CRITICAL FIX: Configure Flask to use the correct template folder
app = Flask(__name__, 
           template_folder='templates',  # This tells Flask where to find HTML files
           static_folder='static')       # Optional: for CSS/JS files if you add them later

app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max file size
app.config['UPLOAD_FOLDER'] = tempfile.gettempdir()

# ============================================================================
# ROUTES
# ============================================================================

@app.route('/')
def index():
    """Serve the main interface"""
    return render_template('upload_biasclean.html')  # This now works correctly

@app.route('/analyze', methods=['POST'])
def analyze():
    """Process CSV - Returns EXACT structure frontend expects"""
    try:
        # 1. Validate
        if 'file' not in request.files:
            return jsonify({'error': 'No file'}), 400
        
        file = request.files['file']
        if not file or not file.filename.endswith('.csv'):
            return jsonify({'error': 'CSV required'}), 400
        
        domain = request.form.get('domain', 'justice')
        
        # 2. Read file
        temp_path = tempfile.NamedTemporaryFile(suffix='.csv', delete=False).name
        file.save(temp_path)
        df = pd.read_csv(temp_path)
        
        # 3. Run pipeline (file saving disabled via monkey patch)
        pipeline = UniversalBiasClean(domain=domain)
        results = pipeline.process_dataset(df=df, auto_approve_threshold=0.80)
        
        # 4. Extract metrics
        diagnostics = results.get('diagnostics', {})
        validation = results.get('validation', {})
        
        initial_bias = diagnostics.get('initial_bias_score', 0)
        final_bias = diagnostics.get('final_bias_score', initial_bias)
        improvement = ((initial_bias - final_bias) / initial_bias * 100) if initial_bias > 0 else 0
        
        # Count biases
        sig_biases = sum(1 for test in diagnostics.get('feature_tests', {}).values() 
                        if test.get('significant_bias', False))
        
        # 5. Save corrected file with SIMPLE filename
        session_id = datetime.now().strftime('%Y%m%d%H%M%S')
        corrected_df = results.get('corrected_df', df)
        
        # SIMPLE filename (no session_id in name)
        corrected_filename = f"corrected_{session_id}.csv"
        corrected_path = os.path.join(app.config['UPLOAD_FOLDER'], corrected_filename)
        corrected_df.to_csv(corrected_path, index=False)
        
        # 6. Create minimal report file
        report_filename = f"report_{session_id}.txt"
        report_path = os.path.join(app.config['UPLOAD_FOLDER'], report_filename)
        
        with open(report_path, 'w') as f:
            f.write(f"BiasClean Analysis Report\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Domain: {domain}\n")
            f.write(f"Original rows: {len(df)}\n")
            f.write(f"Cleaned rows: {len(corrected_df)}\n")
            f.write(f"Bias reduction: {improvement:.1f}%\n")
            f.write(f"Data retention: {validation.get('data_integrity', {}).get('retention_rate', 100):.1f}%\n")
            f.write(f"Significant biases found: {sig_biases}\n")
        
        # 7. Return EXACT structure frontend wants
        response = {
            'detection': {
                'n_rows': len(df),
                'n_columns': len(df.columns),
                'significant_biases': sig_biases
            },
            'removal': {
                'bias_reduction_percent': round(improvement, 1),
                'data_retention_percent': round(validation.get('data_integrity', {}).get('retention_rate', 100), 1),
                'production_ready': improvement > 5
            },
            'files': {
                'corrected': corrected_filename,  # Just filename, no path
                'report': report_filename,
                'validation': f'validation_{session_id}.json'
            },
            'session_id': session_id,
            'report_content': f'Analysis complete. Bias reduced by {improvement:.1f}%.'
        }
        
        os.unlink(temp_path)
        return jsonify(response)
        
    except Exception as e:
        return jsonify({
            'error': 'Server error',
            'details': str(e)[:100]  # Truncate for security
        }), 500


@app.route('/download/<filename>', methods=['GET'])
def download(filename):
    """Simple download - filename only (no session_id in URL)"""
    try:
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        
        if not os.path.exists(file_path):
            app.logger.error(f"File not found: {file_path}")
            return jsonify({'error': 'File not found'}), 404
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=filename,
            mimetype='text/csv' if filename.endswith('.csv') else 'text/plain'
        )
    except Exception as e:
        app.logger.error(f"Download error: {str(e)}")
        return jsonify({'error': 'Download failed'}), 500


@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy', 'service': 'BiasClean'})


if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)
